<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <style type="text/css"><%- await include('page.css', {style}) %></style>
  <style type="text/css"><%- await include('fontello-embedded.css', {style}) %></style>
  <style type="text/css">
  <% if (process.platform == 'win32') { %>
    <%- await include('../../node_modules/highlight.js/styles/github.css') %>
  <% } else { %>
    @media (prefers-color-scheme: light) {
      <%- await include('../../node_modules/highlight.js/styles/github.css') %>
    }
    @media (prefers-color-scheme: dark) {
      <%- await include('dark-mode.css', {style}) %>
      <%- await include('../../node_modules/highlight.js/styles/github-dark.css') %>
    }
  <% } %>
  </style>
</head>
<body>

<div id="messages">
  <% for (const message of history) { %>
    <%- await include('message.html', {message, style}) %>
  <% } %>
</div>

<script type="text/javascript" charset="utf-8">
  // Global variables ======================================================

  // Which element is on top.
  var topElement = null
  // Offset from the top element.
  var scrollOffset = 0
  // Mark page is resizing.
  var ignoreNextScroll = false

  // Initialization ========================================================

  var isIE = /Trident|MSIE/.test(navigator.userAgent)
  if (isIE) {
    // Add endsWith polyfill.
    if (!String.prototype.endsWith) {
      String.prototype.endsWith = function(suffix) {
        return this.indexOf(suffix, this.length - suffix.length) !== -1
      }
    }
  } else {
    // For IE we need to scroll after ready, as the window body's size may be
    // incorrect before showing the browser.
    // For morden browsers scrolling before showing has the best visual effect.
    scrollToBottom()
  }

  // External APIs =========================================================

  // External API for invoking callbacks from outside world.
  var callbacks = {}
  window.executeCallback = function(id, arg) {
    if (!callbacks[id])
      return
    callbacks[id](arg)
    delete callbacks[id]
  }
  // External API to add a new message.
  var messages = document.getElementById('messages')
  window.addMessage = function(html) {
    var children = HTMLToDOM(html)
    for (var i = 0; i < children.length; i++)
      messages.appendChild(children[i])
    // Scroll to bottom for new messages.
    scrollToBottom()
  }
  // External API to update pending message.
  window.updatePending = function(html, back) {
    var text = findPending('text')
    if (!text)
      return
    removeLoader()
    var wasAtBottom = topElement == null
    // Update the message html.
    if (back) {
      // If the tail is something like </p>, then we can insert directly into
      // last child instead of updating whole html.
      var tail = text.innerHTML.slice(text.innerHTML.length - back)
      if (tail.trim().match(/^<\/[a-z]+>$/) && html.endsWith(tail)) {
        text.lastElementChild.insertAdjacentHTML('beforeend', html.slice(0, -back))
      } else {
        console.warn('Updating whole innerHTML, bad tail is', tail)
        text.innerHTML = text.innerHTML.slice(0, -back) + html
      }
    } else {
      text.insertAdjacentHTML('beforeend', html)
    }
    if (wasAtBottom)
      scrollToBottom()
  }
  window.endPending = function() {
    var pending = findPending()
    if (pending)
      pending.removeAttribute('id')
    removeLoader()
    highlightCodes()
  }
  window.regenerateLastMessage = function() {
    var pending = document.getElementById('pending')
    var messages = document.getElementsByClassName('msg')
    if (messages.length == 0) {
      console.error('No message for regenerating.')
      return
    }
    var message = messages[messages.length - 1];
    if (pending && pending != message) {
      console.error('Pending message is not last message.')
      pending.removeAttribute('id')
    }
    message.setAttribute('id', 'pending')
    var text = message.getElementsByClassName('text')[0]
    text.innerHTML = '';
    text.insertAdjacentHTML('beforebegin', '<img id="loader" src="chie://app-file/assets/icons/typing.gif"/>')
  }
  window.markAborted = function(error) {
    var text = findPending('text')
    if (text) {
      var inlineText = text
      // If the last child of text is an element, append into it.
      if (text.lastElementChild &&
          text.lastElementChild == this.lastChild &&
          text.lastElementChild.tagName.toLowerCase() == 'p')
        inlineText = text.lastElementChild
      inlineText.insertAdjacentHTML('beforeend', ' <span class="edited label">(aborted)</span>')
      scrollToBottom()
    }
  }
  window.markError = function(error) {
    var text = findPending('text')
    if (text) {
      text.innerHTML += '<span class="error label">' + error + '</span>'
      scrollToBottom()
    }
  }

  // DOM event handlers ====================================================

  // Capture clicks on <a>.
  window.onclick = function(event) {
    var target = findParent('a', event.target)
    if (!target)
      return false
    // Open links in actual browsers.
    if (target.href.indexOf('#') == -1 && !target.onclick) {
      chie.openLink(target.href)
      return true
    }
    var msg = target.parentNode.parentNode.parentNode
    var index = msg.getAttribute('message-index')
    var content = msg.getElementsByClassName('content')[0]
    // Show popup window to display message.
    if (target.href.endsWith('#show-text')) {
      chie.showText(index, content.getBoundingClientRect())
      chie.showText(index)
      return true
    }
    // Copy text.
    if (target.href.endsWith('#copy-text')) {
      chie.copyText(index)
      // Show ok when clicked,
      var i = target.getElementsByTagName('i')[0];
      var oldClassName = i.className
      i.className = 'icon-ok'
      setTimeout(function () { i.className = oldClassName }, 1000)
      return true
    }
  }
  // Custom menu for links.
  window.oncontextmenu = function(event) {
    var target = findParent('a', event.target)
    if (target && target.href !== '#' && !target.oncontextmenu) {
      chie.openLinkContextMenu(target.href)
      return false
    }
  }
  // Move focus to entry on Tab.
  window.onkeyup = function(event) {
    if (event.keyCode == 9) {
      event.preventDefault()
      chie.focusEntry()
    }
  }
  // Update current top element.
  window.onscroll = function() {
    if (ignoreNextScroll) {
      ignoreNextScroll = false
      return
    }
    var oldTopElement = topElement
    topElement = null
    scrollOffset = 0
    // Check scrolled at page bottom.
    // IE has one pixel offset problem so we use "scrollHeight - 1";
    if (window.pageYOffset + window.innerHeight >= document.body.scrollHeight - 1)
      return
    var messages = document.getElementsByClassName('msg')
    if (messages.length === 0)
      return
    // Search backwards.
    for (var i = messages.length - 1; i >= 0;  --i) {
      var rect = messages[i].getBoundingClientRect()
      topElement = messages[i]
      scrollOffset = rect.top
      if (rect.top < 0)
        break
    }
    // Flip action menu's style between absolute and fixed when scrolling, so
    // it is always visible even when the message is very long.
    if (topElement == oldTopElement)
      return
    if (oldTopElement)
      oldTopElement.getElementsByClassName('action-menu')[0].style.position = 'absolute'
    if (scrollOffset < 0)
      topElement.getElementsByClassName('action-menu')[0].style.position = 'fixed'
  }
  // Make sure the view is always scrolled at current message.
  window.onresize = function() {
    ignoreNextScroll = true
    if (topElement)
      window.scrollTo(0, topElement.getBoundingClientRect().top + window.pageYOffset - scrollOffset)
    else
      scrollToBottom()
  }
  // Catch errors.
  window.onerror = function(message, url, line, column, error) {
    chie.catchDomError(message, url, line, column, error)
  }

  // Ready =================================================================

  // We are ready.
  chie.domReady()
  // See comment above on IE.
  if (isIE)
    scrollToBottom()

  // Helpers ===============================================================

  // Find all unhilighted code blocks and highlight them.
  function highlightCodes() {
    var pres = [].slice.call(document.getElementsByClassName('unhilighted'))
    for (var i = 0; i < pres.length; ++i) {
      var pre = pres[i]
      pre.classList.remove('unhilighted')
      highlightCode(pre, pre.getAttribute('lang'))
    }
  }
  // Highlight a single code block.
  var nextCallbackId = 0
  function highlightCode(element, lang) {
    callbacks[++nextCallbackId] = function(result) {
      if (result)
        element.innerHTML = result
    }
    chie.highlightCode(element.textContent, lang, nextCallbackId)
  }
  // Remove the load indicator.
  function removeLoader() {
    var loader = document.getElementById('loader')
    if (loader)
      loader.parentNode.removeChild(loader)
  }
  // Helper to convert HTML to DOM.
  function HTMLToDOM(html) {
    // Note: Don't use DOMParser, it has problems with applying CSS styles.
    var wrapper = document.createElement('div')
    wrapper.innerHTML = html
    return wrapper.childNodes
  }
  // Find the pending message.
  function findPending(child) {
    var pending = document.getElementById('pending')
    if (!pending) {
      console.error('Unable to find the pending message.')
      return
    }
    if (!child)
      return pending
    var text = pending.getElementsByClassName(child)[0]
    if (!text) {
      console.error('The pending message has no '+ child + ' element.')
      return
    }
    return text
  }
  // Scroll to the bottom of page.
  function scrollToBottom() {
    window.scrollTo(0, document.body.scrollHeight)
  }
  // Helper function to find parent element.
  function findParent(tagName, target) {
    var loops = 0
    while (target && ++loops < 4) {
      if (target.tagName && target.tagName.toLowerCase() === tagName)
        return target
      target = target.parentNode
    }
    return null
  }
</script>
</body>
</html>
