<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <style type="text/css"><%- await include('page.css') %></style>
</head>
<body>

<div id="messages">
  <% for (const message of history) {%>
    <%- await include('message.html', {message}) %>
  <% } %>
</div>

<script type="text/javascript" charset="utf-8">
  // Which element is on top.
  var topElement = null
  // Scroll to the unread marker, or bottom if not found.
  function scrollToUnreadMarker() {
    var marker = document.getElementById('unread-marker')
    if (marker) {
      var rect = marker.getBoundingClientRect()
      window.scrollTo(0, rect.top + window.pageYOffset - (window.innerHeight / 2))
    } else {
      window.scrollTo(0, document.body.scrollHeight)
    }
  }
  // For IE we need to scroll after ready, as the window body's size may be
  // incorrect before showing the browser.
  // For morden browsers scrolling before showing has the best visual effect.
  var isIE = /Trident|MSIE/.test(navigator.userAgent)
  if (!isIE)
    scrollToUnreadMarker()
  // Helper to pass callbacks to UI.
  var callbacks = {}
  var nextCallbackId = 0
  window.executeCallback = function(id, arg) {
    if (!callbacks[id])
      return
    callbacks[id](arg)
    delete callbacks[id]
  }
  // Helper to dynamically load an image which requires authorization.
  function loadImage(element, url) {
    callbacks[++nextCallbackId] = function(result) {
      element.src = result
    }
    chie.fetchImage(url, nextCallbackId)
  }
  // Load all images.
  function loadAllImages() {
    var imgs = [].slice.call(document.getElementsByClassName('delayed-image'))
    for (var i = 0; i < imgs.length; ++i) {
      var img = imgs[i]
      img.classList.remove('delayed-image')
      loadImage(img, img.getAttribute('data-url'))
    }
  }
  loadAllImages()
  // Helper to convert HTML to DOM.
  function HTMLToDOM(html) {
    // Note: Don't use DOMParser, it has problems with applying CSS styles.
    var wrapper = document.createElement('div')
    wrapper.innerHTML = html
    return wrapper.childNodes
  }
  // External API to add a new message.
  var messages = document.getElementById('messages')
  window.addMessage = function(html) {
    var children = HTMLToDOM(html)
    for (var i = 0; i < children.length; i++)
      messages.appendChild(children[i])
    // Scroll to bottom for new messages.
    window.scrollTo(0, document.body.scrollHeight)
    // Load images.
    loadAllImages()
  }
  // External API to delete message.
  window.deleteMessage = function(id) {
    messages.removeChild(document.getElementById(id))
  }
  // Helper to scroll to previous top element.
  var scrollOffset = 0
  var ignoreNextScroll = false
  function scrollToPreivousTopElement() {
    ignoreNextScroll = true
    if (topElement)
      window.scrollTo(0, topElement.getBoundingClientRect().top + window.pageYOffset - scrollOffset)
    else
      window.scrollTo(0, document.body.scrollHeight)
  }
  // External API to update pending message.
  window.updatePending = function(html, back) {
    var msg = document.getElementById('pending').getElementsByClassName('text')[0]
    if (msg) {
      if (back) {
        console.log(back, msg.innerHTML.slice(0, -back), html)
        msg.innerHTML = msg.innerHTML.slice(0, -back) + html
      } else
        msg.innerHTML += html
      scrollToPreivousTopElement()
    }
    var loader = document.getElementById('loader')
    loader.remove()
  }
  window.endPending = function() {
    var pending = document.getElementById('pending')
    if (pending)
      pending.removeAttribute('id')
  }
  // Helper function to find parent element.
  function findParent(tagName, target) {
    var loops = 0
    while (target && ++loops < 4) {
      if (target.tagName && target.tagName.toLowerCase() === tagName)
        return target
      target = target.parentNode
    }
    return null
  }
  // Open links in actual browsers.
  window.onclick = function(event) {
    var target = findParent('a', event.target)
    if (target && target.href !== '#' && !target.onclick) {
      chie.openLink(target.href)
      return false
    }
  }
  // Custom menu for links.
  window.oncontextmenu = function(event) {
    var target = findParent('a', event.target)
    if (target && target.href !== '#' && !target.oncontextmenu) {
      chie.openLinkContextMenu(target.href)
      return false
    }
  }
  // Update current top element.
  window.onscroll = function() {
    if (ignoreNextScroll) {
      ignoreNextScroll = false
      return
    }
    topElement = null
    scrollOffset = 0
    if (window.scrollY + window.innerHeight >= document.body.scrollHeight) {
      // At the bottom of the page.
      return
    }
    var messages = document.getElementsByClassName('msg')
    if (messages.length === 0)
      return
    // Search backwards.
    for (var i = messages.length - 1; i >= 0;  --i) {
      var rect = messages[i].getBoundingClientRect()
      if (rect.top < 0)
        break
      topElement = messages[i]
      scrollOffset = rect.top
    }
  }
  // Make sure the view is always scrolled at current message.
  window.onresize = scrollToPreivousTopElement
  // We are ready.
  chie.notifyReady()
  // See comment above on IE.
  if (isIE)
    scrollToUnreadMarker()
</script>
</body>
</html>
